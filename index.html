<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>DNS Check → Redirect</title>
<style>
  html,body { margin:0; font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Arial }
  .wrap { max-width:720px; margin:12vh auto; padding:16px; text-align:center }
  .spinner { width:36px; height:36px; border:4px solid #eee; border-top-color:#555; border-radius:50%; margin:16px auto; animation:spin 1s linear infinite }
  @keyframes spin { to { transform:rotate(360deg) } }
  .small { color:#666; font-size:12px; margin-top:8px }
</style>
</head>
<body>
<div class="wrap">
  <h2>Checking your DNS…</h2>
  <div class="spinner" aria-hidden="true"></div>
  <div id="msg" class="small">Please wait, redirecting to the form.</div>
</div>

<script>
(async () => {
  const qs = new URLSearchParams(location.search);
  const debug = qs.get('debug') === '1';

  // REQUIRED input params:
  // - jotform: full URL to your JotForm (URL-encoded if you like)
  // - domain: domain to inspect (e.g., example.com)
  // - expectedA: comma-separated IPv4 list (optional)
  // - expectedC: expected CNAME target (optional)
  // OPTIONAL:
  // - cnameHost: host to check for CNAME (default 'www', use '@' for root)
  // - delay: ms to wait before redirect (default 0)
  // - passthrough: comma-separated list of param names to pass through to JotForm unchanged
  let jotform = (qs.get('jotform') || '').trim();
  const domain = (qs.get('domain') || '').trim();
  const expectedA = (qs.get('expectedA') || '').split(',').map(s => s.trim()).filter(Boolean);
  const expectedC = (qs.get('expectedC') || '').trim();
  const cnameHost = (qs.get('cnameHost') || 'www').trim() || 'www';
  const delayMs = parseInt(qs.get('delay') || '0', 10) || 0;
  const passthroughList = (qs.get('passthrough') || '').split(',').map(s => s.trim()).filter(Boolean);

  const $ = id => document.getElementById(id);
  const canon = s => String(s || '').trim().replace(/\.$/, '').toLowerCase();

  function setMsg(t){ const el = $('msg'); if (el) el.textContent = t; }

  if (!jotform) { setMsg('Missing ?jotform=FORM_URL'); return; }
  if (!domain || (!expectedA.length && !expectedC)) { setMsg('Missing DNS params: need domain and expectedA and/or expectedC'); return; }

  // Robust DNS-over-HTTPS (Cloudflare → Google)
  async function doh(name, type) {
    const urls = [
      `https://cloudflare-dns.com/dns-query?ct=application/dns-json&name=${encodeURIComponent(name)}&type=${encodeURIComponent(type)}`,
      `https://dns.google/resolve?name=${encodeURIComponent(name)}&type=${encodeURIComponent(type)}`
    ];
    let lastErr;
    for (const url of urls) {
      try {
        const headers = url.includes('cloudflare-dns.com') ? { 'accept':'application/dns-json' } : {};
        const r = await fetch(url, { mode:'cors', headers });
        if (!r.ok) throw new Error(`HTTP ${r.status} from ${new URL(url).hostname}`);
        const j = await r.json();
        return (j.Answer || []).map(a => a.data);
      } catch (e) { lastErr = e; }
    }
    throw lastErr || new Error('All DoH providers failed');
  }

  // run the check
  let ok = false, aMatch = null, cMatch = null, liveA = [], liveC = [];
  try {
    // A at root
    liveA = (await doh(domain, 'A')).filter(v => /^\d+\.\d+\.\d+\.\d+$/.test(v));
    // CNAME at host
    const fqdn = (cnameHost === '@' ? domain : `${cnameHost}.${domain}`);
    liveC = (await doh(fqdn, 'CNAME')).map(canon);

    aMatch = expectedA.length ? expectedA.every(ip => liveA.includes(ip)) : null;
    cMatch = expectedC ? liveC.includes(canon(expectedC)) : null;

    const checks = [aMatch, cMatch].filter(v => v !== null);
    ok = checks.length ? checks.every(Boolean) : false;

    if (debug) console.log({domain, expectedA, expectedC, cnameHost, liveA, liveC, aMatch, cMatch, ok});
  } catch (e) {
    // If DNS fails entirely, mark as not valid; still redirect and let the form show guidance.
    ok = false;
    if (debug) console.error('DoH error:', e);
  }

  // Build the JotForm URL with dnsvalid=yes|no (and optional pass-throughs)
  try {
    jotform = decodeURIComponent(jotform); // in case caller URL-encoded it
  } catch(_) {}

  let target;
  try {
    target = new URL(jotform);
  } catch {
    setMsg('Invalid JotForm URL'); return;
  }

  // Mandatory param
  target.searchParams.set('dnsvalid', ok ? 'yes' : 'no');

  // Useful: include what we saw / expected (optional; add hidden fields in JotForm if you want to capture)
  if (expectedA.length) target.searchParams.set('expectedA', expectedA.join(','));
  if (expectedC)        target.searchParams.set('expectedC', expectedC);
  target.searchParams.set('observedA', liveA.join(', '));
  target.searchParams.set('observedC', liveC.join(', '));
  target.searchParams.set('domain', domain);
  target.searchParams.set('cnameHost', cnameHost);

  // Pass through any extra params the caller asked to keep
  for (const key of passthroughList) {
    if (qs.has(key)) target.searchParams.set(key, qs.get(key));
  }

  setMsg(ok ? 'DNS valid — redirecting…' : 'DNS not valid — redirecting…');

  const go = () => location.replace(target.toString());
  delayMs > 0 ? setTimeout(go, delayMs) : go();
})();
</script>
</body>
</html>

